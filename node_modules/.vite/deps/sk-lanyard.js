import {
  readable
} from "./chunk-Y5HQ3MVM.js";
import "./chunk-ZQ7TCJTX.js";
import "./chunk-OROXOI2D.js";

// node_modules/sk-lanyard/dist/index.js
var n = {};
(() => {
  n.d = (e, t2) => {
    for (var r2 in t2) {
      if (n.o(t2, r2) && !n.o(e, r2)) {
        Object.defineProperty(e, r2, { enumerable: true, get: t2[r2] });
      }
    }
  };
})();
(() => {
  n.o = (e, n2) => Object.prototype.hasOwnProperty.call(e, n2);
})();
if (typeof n !== "undefined")
  n.ab = new URL(".", import.meta.url).pathname.slice(import.meta.url.match(/^file:\/\/\/\w:/) ? 1 : 0, -1) + "/";
var t = {};
n.d(t, { D: () => s, q: () => useLanyard });
var x = (e) => {
  var t2 = {};
  n.d(t2, e);
  return t2;
};
var r = x({ ["readable"]: () => readable });
var s;
(function(e) {
  e[e["EVENT"] = 0] = "EVENT";
  e[e["HELLO"] = 1] = "HELLO";
  e[e["INITIALIZE"] = 2] = "INITIALIZE";
  e[e["HEARTBEAT"] = 3] = "HEARTBEAT";
})(s || (s = {}));
var a = "https://api.lanyard.rest/v1";
var o = "wss://api.lanyard.rest/socket";
function useLanyard(e) {
  if (e.method === "rest") {
    const n2 = (0, r.readable)(void 0, (n3) => {
      lanyardRest(e, n3);
    });
    return n2;
  }
  if (e.method === "ws") {
    if ("id" in e) {
      const n3 = (0, r.readable)(void 0, (n4) => {
        lanyardWS(e, n4);
      });
      return n3;
    }
    const n2 = (0, r.readable)(void 0, (n3) => {
      lanyardWS(e, n3);
    });
    return n2;
  }
}
async function lanyardRest(e, n2) {
  var _a, _b;
  if (typeof window === "undefined") {
    return;
  }
  const t2 = (_a = e.restUrl) != null ? _a : a;
  const lanyardFetch = async () => await fetch(`${t2}/users/${e.id}`).then((e2) => e2.json());
  const updateStore = async () => {
    const e2 = await lanyardFetch();
    if (e2.success) {
      n2(e2.data);
    } else {
      throw new Error(e2.error.message);
    }
  };
  updateStore();
  setInterval(updateStore, (_b = e.pollInterval) != null ? _b : 5e3);
}
async function lanyardWS(e, n2) {
  var _a;
  if (typeof window === "undefined") {
    return;
  }
  const t2 = (_a = e.wsUrl) != null ? _a : o;
  const r2 = new WebSocket(t2);
  const send = (e2) => r2.send(JSON.stringify(e2));
  const recv = (e2) => {
    r2.addEventListener("message", e2);
  };
  const once = () => new Promise((e2) => {
    const fn = (n3) => {
      r2.removeEventListener("message", fn);
      e2(JSON.parse(n3.data));
    };
    r2.addEventListener("message", fn);
  });
  const waitInit = () => new Promise((e2, n3) => {
    const open = () => {
      r2.removeEventListener("open", open);
      e2();
    };
    r2.addEventListener("open", open);
    const err = () => {
      r2.removeEventListener("error", err);
      n3();
    };
    r2.addEventListener("error", err);
  });
  await waitInit();
  if ("all" in e) {
    send({ op: s.INITIALIZE, d: { subscribe_to_all: true } });
  }
  if ("ids" in e) {
    send({ op: s.INITIALIZE, d: { subscribe_to_ids: e.ids } });
  }
  if ("id" in e) {
    send({ op: s.INITIALIZE, d: { subscribe_to_id: e.id } });
  }
  const a2 = await once();
  const d2 = a2.d.heartbeat_interval;
  const heartbeat = () => {
    send({ op: s.HEARTBEAT, d: void 0 });
  };
  setInterval(heartbeat, d2);
  const i2 = await once();
  const c = i2.d;
  n2(c);
  recv((e2) => {
    const t3 = JSON.parse(e2.data);
    if ("user_id" in t3.d) {
      const { user_id: e3, ...r3 } = t3.d;
      c[t3.d.user_id] = r3;
      n2(c);
    } else {
      n2({ ...t3.d });
    }
  });
}
var d = t.D;
var i = t.q;
export {
  d as LanyardOpcode,
  i as useLanyard
};
//# sourceMappingURL=sk-lanyard.js.map
